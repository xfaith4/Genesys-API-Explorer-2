{
  "id": "gc.webrtc.disconnects.v1",
  "name": "WebRTC Disconnects",
  "version": "1.0.0",
  "maturity": "alpha",
  "owner": "Ops Insights",
  "expectedRuntimeSec": 120,
  "description": "Finds conversations that include WebRTC (provider) voice sessions with matching errorCode patterns and summarizes impact by queue and division.",
  "scopes": ["analytics:read", "routing:read", "authorization:read"],
  "tags": ["webrtc", "voice", "reliability", "triage"],
  "evidenceScript": "param($ctx)\n\n$rows = @($ctx.Data.webrtcRows)\n$total = $rows.Count\n\n$severity = 'Info'\nif ($total -ge 25) { $severity = 'Warning' }\nif ($total -ge 100) { $severity = 'Critical' }\n\n$topQueue = $null\ntry { $topQueue = @($ctx.Data.queueSummaryEnriched | Sort-Object Count -Descending | Select-Object -First 1) } catch {}\n$qLabel = ''\nif ($topQueue) {\n  $qName = ''\n  try { if ($topQueue.Queue -and $topQueue.Queue.name) { $qName = [string]$topQueue.Queue.name } } catch {}\n  if (-not $qName) { $qName = [string]$topQueue.QueueId }\n  $qLabel = \" Top queue: $qName ($($topQueue.Count)).\"\n}\n\n$impact = if ($total -gt 0) { \"$total conversations show WebRTC errorCode indicators in the selected window.$qLabel\" } else { 'No WebRTC errorCode indicators detected in the selected window.' }\n\n$actions = @(\n  'Validate Edge/network health and WebRTC connectivity (ICE/STUN/TURN) for the impacted time window.',\n  'Compare the window to recent changes (config + releases) and carrier/network events.',\n  'Review top queues/divisions and sample conversations to confirm error patterns.'\n)\n\nreturn [pscustomobject]@{\n  Severity = $severity\n  Impact = $impact\n  LikelyCauses = @(\n    'WebRTC disconnect/error spikes are often driven by network instability, NAT/firewall behavior, TURN/STUN reachability, endpoint/browser changes, or downstream media path disruptions.'\n  )\n  RecommendedActions = $actions\n  WhyThisMatters = 'WebRTC disconnects degrade customer experience and agent productivity; clustering by queue/division helps target investigation and remediation.'\n  BlastRadius = [pscustomobject]@{ Queues = @($ctx.Data.queueSummaryEnriched | Sort-Object Count -Descending | Select-Object -First 10 | ForEach-Object { if ($_.Queue -and $_.Queue.name) { $_.Queue.name } else { $_.QueueId } }) }\n}\n",
  "parameters": {
    "startDate": { "type": "string", "required": true, "description": "ISO-8601 UTC start timestamp (e.g. 2025-12-01T00:00:00Z)." },
    "endDate": { "type": "string", "required": true, "description": "ISO-8601 UTC end timestamp (e.g. 2025-12-08T00:00:00Z)." },
    "errorCodeRegex": { "type": "string", "default": "webrtc|ice|stun|turn|rtp|media", "description": "Regex pattern evaluated against segment errorCode values (PowerShell -match). Empty = any errorCode." },
    "maxResults": { "type": "int", "default": 2000, "description": "Hard cap on total conversations collected via job results pagination." }
  },
  "pipeline": [
    {
      "id": "detailsJob",
      "type": "jobpoll",
      "maxPages": 20,
      "collect": "conversations",
      "create": {
        "method": "POST",
        "uri": "/api/v2/analytics/conversations/details/jobs",
        "bodyTemplate": {
          "interval": "{{startDate}}/{{endDate}}",
          "order": "desc",
          "orderBy": "conversationStart",
          "segmentFilters": [
            {
              "type": "and",
              "predicates": [
                { "dimension": "mediaType", "operator": "matches", "value": "voice" },
                { "dimension": "provider", "operator": "matches", "value": "WebRTC" },
                { "dimension": "errorCode", "operator": "exists" }
              ]
            }
          ],
          "paging": { "pageSize": 200, "pageNumber": 1 }
        }
      }
    },
    {
      "id": "webrtcRows",
      "type": "compute",
      "script": "param($ctx)\n\nfunction SafeStr($v) { if ($null -eq $v) { return '' } try { return [string]$v } catch { return '' } }\n\n$cap = 0\ntry { $cap = [int]$ctx.Parameters.maxResults } catch { $cap = 2000 }\nif ($cap -lt 1) { $cap = 1 }\n\n$pattern = ''\ntry {\n  if ($ctx.Parameters -and ($ctx.Parameters.PSObject.Properties.Name -contains 'errorCodeRegex')) {\n    $pattern = SafeStr $ctx.Parameters.errorCodeRegex\n  }\n} catch { $pattern = '' }\n\n$convs = @()\ntry { $convs = @($ctx.Data.detailsJob.Items) } catch { $convs = @() }\nif ($convs.Count -gt $cap) { $convs = @($convs | Select-Object -First $cap) }\n\n$rows = New-Object System.Collections.ArrayList\n\nforeach ($c in $convs) {\n  if (-not $c) { continue }\n\n  $conversationId = ''\n  try {\n    if ($c.PSObject.Properties.Name -contains 'conversationId' -and $c.conversationId) { $conversationId = SafeStr $c.conversationId }\n    elseif ($c.PSObject.Properties.Name -contains 'id' -and $c.id) { $conversationId = SafeStr $c.id }\n  } catch { $conversationId = '' }\n\n  $start = SafeStr $c.conversationStart\n  $end = SafeStr $c.conversationEnd\n\n  $divisionIds = @()\n  try {\n    if ($c.PSObject.Properties.Name -contains 'divisionIds' -and $c.divisionIds) { $divisionIds = @($c.divisionIds) }\n    elseif ($c.PSObject.Properties.Name -contains 'divisionId' -and $c.divisionId) { $divisionIds = @($c.divisionId) }\n  } catch {}\n\n  $hits = New-Object System.Collections.ArrayList\n\n  foreach ($p in @($c.participants)) {\n    foreach ($s in @($p.sessions)) {\n      $provider = SafeStr $s.provider\n      if ($provider -ne 'WebRTC') { continue }\n      if ((SafeStr $s.mediaType) -ne 'voice') { continue }\n\n      $segments = @($s.segments)\n      if ($segments.Count -eq 0) { continue }\n\n      foreach ($seg in $segments) {\n        if (-not $seg) { continue }\n\n        $dt = SafeStr $seg.disconnectType\n        $q = SafeStr $seg.queueId\n        $err = SafeStr $seg.errorCode\n        if ([string]::IsNullOrWhiteSpace($err)) { continue }\n        if (-not [string]::IsNullOrWhiteSpace($pattern) -and ($err -notmatch $pattern)) { continue }\n\n        $segStart = SafeStr $seg.segmentStart\n        [void]$hits.Add([pscustomobject]@{ SegmentStart=$segStart; DisconnectType=$dt; QueueId=$q; ErrorCode=$err; Provider=$provider })\n      }\n    }\n  }\n\n  if ($hits.Count -eq 0) { continue }\n\n  $queueIds = @($hits | Where-Object { $_.QueueId } | Select-Object -ExpandProperty QueueId -Unique)\n  $disconnectTypes = @($hits | Where-Object { $_.DisconnectType } | Select-Object -ExpandProperty DisconnectType -Unique)\n  $errorCodes = @($hits | Where-Object { $_.ErrorCode } | Select-Object -ExpandProperty ErrorCode -Unique)\n\n  [void]$rows.Add([pscustomobject]@{\n    ConversationId = $conversationId\n    ConversationStartUtc = $start\n    ConversationEndUtc = $end\n    DivisionIds = ($divisionIds -join ',')\n    QueueIds = ($queueIds -join ',')\n    DisconnectTypes = ($disconnectTypes -join ',')\n    ErrorCodes = ($errorCodes -join ',')\n    HitCount = $hits.Count\n  })\n}\n\n@($rows)\n"
    },
    {
      "id": "queueSummary",
      "type": "compute",
      "script": "param($ctx)\n\nfunction AddCount($map, $key) {\n  if ([string]::IsNullOrWhiteSpace($key)) { return }\n  if (-not $map.ContainsKey($key)) { $map[$key] = 0 }\n  $map[$key] = [int]$map[$key] + 1\n}\n\n$map = @{}\nforeach ($r in @($ctx.Data.webrtcRows)) {\n  foreach ($q in ([string]$r.QueueIds).Split(',')) {\n    AddCount -map $map -key ($q.Trim())\n  }\n}\n\n$items = foreach ($k in ($map.Keys | Sort-Object)) {\n  [pscustomobject]@{ QueueId = $k; Count = $map[$k] }\n}\n\n$items | Sort-Object Count -Descending\n"
    },
    {
      "id": "queueSummaryEnriched",
      "type": "join",
      "sourceStepId": "queueSummary",
      "itemsProperty": "Items",
      "key": "QueueId",
      "assign": "Queue",
      "maxUnique": 200,
      "lookup": { "method": "GET", "uri": "/api/v2/routing/queues/{id}" }
    },
    {
      "id": "divisionSummary",
      "type": "compute",
      "script": "param($ctx)\n\nfunction AddCount($map, $key) {\n  if ([string]::IsNullOrWhiteSpace($key)) { return }\n  if (-not $map.ContainsKey($key)) { $map[$key] = 0 }\n  $map[$key] = [int]$map[$key] + 1\n}\n\n$map = @{}\nforeach ($r in @($ctx.Data.webrtcRows)) {\n  foreach ($d in ([string]$r.DivisionIds).Split(',')) {\n    AddCount -map $map -key ($d.Trim())\n  }\n}\n\n$items = foreach ($k in ($map.Keys | Sort-Object)) {\n  [pscustomobject]@{ DivisionId = $k; Count = $map[$k] }\n}\n\n$items | Sort-Object Count -Descending\n"
    },
    {
      "id": "divisionSummaryEnriched",
      "type": "join",
      "sourceStepId": "divisionSummary",
      "itemsProperty": "Items",
      "key": "DivisionId",
      "assign": "Division",
      "maxUnique": 200,
      "lookup": { "method": "GET", "uri": "/api/v2/authorization/divisions/{id}" }
    },
    {
      "id": "metricConversations",
      "type": "metric",
      "script": "param($ctx)\n$items = @($ctx.Data.webrtcRows)\n[pscustomobject]@{ title='WebRTC Error Conversations'; value=$items.Count; items=$items }\n"
    },
    {
      "id": "metricByQueue",
      "type": "metric",
      "script": "param($ctx)\n$items = @($ctx.Data.queueSummaryEnriched)\n$rows = foreach ($it in $items) {\n  $name = ''\n  try { if ($it.Queue -and $it.Queue.name) { $name = [string]$it.Queue.name } } catch {}\n  [pscustomobject]@{ QueueId=$it.QueueId; QueueName=$name; Count=$it.Count }\n}\n[pscustomobject]@{ title='By Queue'; value=$rows.Count; items=@($rows) }\n"
    },
    {
      "id": "metricByDivision",
      "type": "metric",
      "script": "param($ctx)\n$items = @($ctx.Data.divisionSummaryEnriched)\n$rows = foreach ($it in $items) {\n  $name = ''\n  try { if ($it.Division -and $it.Division.name) { $name = [string]$it.Division.name } } catch {}\n  [pscustomobject]@{ DivisionId=$it.DivisionId; DivisionName=$name; Count=$it.Count }\n}\n[pscustomobject]@{ title='By Division'; value=$rows.Count; items=@($rows) }\n"
    },
    {
      "id": "drilldownSample",
      "type": "drilldown",
      "script": "param($ctx)\n$items = @($ctx.Data.webrtcRows | Select-Object -First 250)\n[pscustomobject]@{ title='Sample Conversations (first 250)'; items=$items }\n"
    }
  ]
}

